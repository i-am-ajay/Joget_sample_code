package org.joget.geowatch.db.service.impl;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.joget.commons.util.LogUtil;import org.joget.directory.model.Employment;import org.joget.directory.model.Group;import org.joget.directory.model.User;import org.joget.geowatch.api.dto.Location;import org.joget.geowatch.api.dto.out.resp.TripOutResp;import org.joget.geowatch.api.dto.out.resp.VehicleOutResp;import org.joget.geowatch.db.dao.Dao;import org.joget.geowatch.db.dao.impl.AbstractDao;import org.joget.geowatch.db.dto.Department;import org.joget.geowatch.db.dto.Event;import org.joget.geowatch.db.dto.GhtVehicle;import org.joget.geowatch.db.dto.Log;import org.joget.geowatch.db.dto.Trip;import org.joget.geowatch.db.dto.TripSnapShot;import org.joget.geowatch.db.dto.inner.RouteMapInnerEntity;import org.joget.geowatch.db.dto.type.TripLifeStateType;import org.joget.geowatch.db.dto.type.UserRoleType;import org.joget.geowatch.db.service.TripService;import org.joget.geowatch.ghtrack.service.GhTourService;import org.joget.geowatch.util.JogetUtil;import org.joget.workflow.util.WorkflowUtil;import org.springframework.util.Base64Utils;import java.io.BufferedInputStream;import java.io.ByteArrayOutputStream;import java.net.HttpURLConnection;import java.net.URL;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.List;import java.util.concurrent.TimeUnit;import static java.net.HttpURLConnection.HTTP_OK;import static java.util.Calendar.SECOND;import static org.apache.commons.lang3.StringUtils.isNotBlank;import static org.joget.geowatch.app.AppProperties.*;import static org.joget.geowatch.db.dao.impl.AbstractDao.OrderType.ASC;import static org.joget.geowatch.db.dao.impl.AbstractDao.OrderType.DESC;import static org.joget.geowatch.db.dto.type.TripLifeStateType.APPROVED;import static org.joget.geowatch.db.dto.type.TripLifeStateType.LIVE;import static org.joget.geowatch.db.dto.type.TripLifeSubStateType.TRIP;import static org.joget.geowatch.util.DateUtil.getJogetDate;/** * Created by klebedyantsev on 2017-12-26 */public class TripServiceImpl implements TripService {    private static final String TAG = TripServiceImpl.class.getSimpleName();    private SessionFactory sessionFactory;    private Dao<Trip> tripDao;    private Dao<Log> logDao;    private Dao<Event> eventDao;    private Dao<GhtVehicle> ghtVehicleDao;    private Dao<Department> departmentDao;    private Dao<TripSnapShot> tripSnapShotDao;    private GhTourService ghTourService;    public TripServiceImpl(            SessionFactory sessionFactory, Dao<Trip> tripDao, Dao<Log> logDao,            Dao<Event> eventDao, Dao<GhtVehicle> ghtVehicleDao, Dao<Department> departmentDao,            Dao<TripSnapShot> tripSnapShotDao, GhTourService ghTourService) {        this.sessionFactory = sessionFactory;        this.tripDao = tripDao;        this.logDao = logDao;        this.eventDao = eventDao;        this.ghtVehicleDao = ghtVehicleDao;        this.departmentDao = departmentDao;        this.tripSnapShotDao = tripSnapShotDao;        this.ghTourService = ghTourService;    }    @Override    public void update(Trip trip) throws Exception {        Session session = null;        Transaction transaction = null;        try {            session = sessionFactory.getCurrentSession();            transaction = session.beginTransaction();            trip.setDateModified(new Date());            tripDao.update(trip);            transaction.commit();            transaction = null;        } finally {            if (transaction != null && !transaction.wasCommitted()) {                LogUtil.warn(TAG,"TRANSACTION ROLLBACK TripServiceImpl.update(Trip trip). tripId: " + trip.getC__id());                transaction.rollback();            }            if (session != null && session.isOpen()) session.close();        }    }    @Override    public void update(String tripId, String haulierTripHistorySnapshot, String trailerTripHistorySnapshot, String rmoTripHistorySnapshot) throws Exception {        Session session = null;        Transaction transaction = null;        try {            session = sessionFactory.getCurrentSession();            transaction = session.beginTransaction();            Trip trip = tripDao.findById(tripId);            if (trip != null) {                trip.setHaulierTripHistorySnapshot(haulierTripHistorySnapshot);                trip.setRmoTripHistorySnapshot(rmoTripHistorySnapshot);                trip.setTrailerTripHistorySnapshot(trailerTripHistorySnapshot);                tripDao.update(trip);            }            transaction.commit();            transaction = null;        } finally {            if (transaction != null && !transaction.wasCommitted()) {                LogUtil.warn(TAG,"TRANSACTION ROLLBACK  TripServiceImpl.update(String tripId, String haulierTripHistorySnapshot, String trailerTripHistorySnapshot, String rmoTripHistorySnapshot): tripId: " + tripId);                transaction.rollback();            }            if (session != null && session.isOpen()) session.close();        }    }    public Trip getTrip(String id) throws Exception {        Session session = null;        Transaction transaction = null;        Trip trip = null;        try {            session = sessionFactory.getCurrentSession();            transaction = session.beginTransaction();            trip = tripDao.findById(id);            transaction.commit();            transaction = null;            return trip;        } finally {            if (transaction != null && !transaction.wasCommitted()) {                LogUtil.warn(TAG,"TRANSACTION ROLLBACK TripServiceImpl.getLiveTrip().");                transaction.rollback();            }            if (session != null && session.isOpen()) session.close();        }    }    public List<Trip> getLiveTrip() throws Exception {        List<Trip> res;        Session session = null;        Transaction transaction = null;        try {            session = sessionFactory.getCurrentSession();            transaction = session.beginTransaction();            res = tripDao.find(                    "SELECT e FROM " + Trip.class.getSimpleName() + " e " +                            "WHERE e.liveState = :state ",                    new AbstractDao.StrParam("state", LIVE.name()));            transaction.commit();            transaction = null;            return res;        } finally {            if (transaction != null && !transaction.wasCommitted()) {                LogUtil.warn(TAG,"TRANSACTION ROLLBACK TripServiceImpl.getLiveTrip().");                transaction.rollback();            }            if (session != null && session.isOpen()) session.close();        }    }    @Override    public List<TripOutResp> listTrips(User user, TripLifeStateType liveState) throws Exception {        long startTime = System.currentTimeMillis();        List<TripOutResp> res = new ArrayList<>();        Session session = null;        Transaction transaction = null;        try {            String conditions = findUserDepartment(user, liveState);            session = sessionFactory.getCurrentSession();            transaction = session.beginTransaction();            List<Trip> tripList = tripDao.find(conditions,                    new AbstractDao.Order[]{new AbstractDao.Order("e.name", ASC)});            if (tripList != null) for (Trip trip : tripList) {                try {                    TripOutResp tripOutResp = TripOutResp.update(new TripOutResp(), trip, user, false);                    if (tripOutResp != null) res.add(tripOutResp);                } catch (Exception e) {                    LogUtil.error(TAG, e, "ERROR. tripId: " + trip.getId());                }            }            transaction.commit();            transaction = null;            long endTime = System.currentTimeMillis();            LogUtil.info(TAG, "Full work time: " + (endTime - startTime));            return res;        } finally {            if (transaction != null && !transaction.wasCommitted()) {                LogUtil.warn(TAG,"TRANSACTION ROLLBACK listTrips(User user, TripLifeStateType liveState).");                transaction.rollback();            }            if (session != null && session.isOpen()) session.close();        }    }    @Override    public TripOutResp getLifeTripDetails(User user, String id) throws Exception {        TripOutResp tripOutResp = null;        Session session = null;        Transaction transaction = null;        try {            session = sessionFactory.getCurrentSession();            transaction = session.beginTransaction();            Trip trip = tripDao.findById(id);            tripOutResp = TripOutResp.update(new TripOutResp(), trip, user, true);            transaction.commit();            return tripOutResp;        } finally {            if (transaction != null && !transaction.wasCommitted()) {                LogUtil.warn(TAG,"TRANSACTION ROLLBACK getLifeTripDetails(User user, String id). tripId:"+id);                transaction.rollback();            }            if (session != null && session.isOpen()) session.close();        }    }    @Override    public TripOutResp getLifeTripByC__id(User user, String tripId) throws Exception {        TripOutResp tripOutResp = null;        Session session = null;        Transaction transaction = null;        try {            session = sessionFactory.getCurrentSession();            transaction = session.beginTransaction();            Trip trip = tripDao.findSingle(                    "SELECT e FROM " + Trip.class.getSimpleName() + " e " +                            "WHERE e.c__id = :id",                    new AbstractDao.StrParam("id", tripId));            tripOutResp = TripOutResp.update(new TripOutResp(), trip, user, true);            transaction.commit();            transaction = null;            return tripOutResp;        } finally {            if (transaction != null && !transaction.wasCommitted()) {                LogUtil.warn(TAG,"TRANSACTION ROLLBACK getLifeTripByC__id(User user, String tripId). tripId:" + tripId);                transaction.rollback();            }            if (session != null && session.isOpen()) session.close();        }    }    @Override    public void transferTripToLife(int timeBeforeLive, TimeUnit unit) throws Exception {        Date date = new Date();        Calendar cal = Calendar.getInstance();        cal.setTime(date);        cal.add(SECOND, ((int) unit.toSeconds((long) timeBeforeLive)));        List<Trip> liveTripList = null;        List<Trip> approvedTripList = getApprovedTripList();        if (approvedTripList != null) {            liveTripList = new ArrayList<>(approvedTripList.size());            for (Trip trip : approvedTripList) {                try {                    Date startDate = getJogetDate(trip.getStartDateTime());                    if (startDate.before(cal.getTime())) liveTripList.add(trip);                } catch (Exception e) {                    LogUtil.error(TAG, e, "ERROR. tripId: " + trip.getId());                }            }        }        if (liveTripList != null && liveTripList.size() > 0) {            for (Trip trip : liveTripList) {                Session session = null;                Transaction transaction = null;                try {                    add2GhtTour(trip);                    String snapshot = createRouteSnapshot(trip.getImageRouteMap());                    TripSnapShot tripSnapShot = TripSnapShot.update(new TripSnapShot(), trip, snapshot);                    {                        session = sessionFactory.getCurrentSession();                        transaction = session.beginTransaction();                        if (PLUGIN_DEBUG_MODE) {                            LogUtil.info(TAG, "TransferTripToLife: " + trip.getC__id());                        }                        trip.setLiveState(LIVE);                        trip.setLiveSubState(TRIP);                        trip.setDateModified(new Date());                        tripDao.update(trip);                        tripSnapShotDao.save(tripSnapShot);                        transaction.commit();                        transaction = null;                    }                    add2GhtTour(trip);                } catch (Exception e) {                    LogUtil.error(TAG, e, "ERROR. Can't transfer trip to live. tripId: " + trip.getId());                } finally {                    if (transaction != null && !transaction.wasCommitted()) {                        LogUtil.warn(TAG,"TRANSACTION ROLLBACK transferTripToLife(int timeBeforeLive, TimeUnit unit). tripId: " + trip.getC__id());                        transaction.rollback();                    }                    if (session != null && session.isOpen()) session.close();                }                JogetUtil.updateJogetProccess(trip.getId(), "liveState", LIVE.name());                JogetUtil.updateJogetProccess(trip.getId(), "liveSubState", TRIP.name());                JogetUtil.updateJogetProccess(trip.getId(), "_id", trip.getC__id());                JogetUtil.completeActivity(trip.getId(), JOGET_PROCESS_TRIP_LIVE_ROUTE_ID);            }        } else LogUtil.info(TAG, "Trip list for transfer to live is empty");    }    private void add2GhtTour(Trip trip) throws Exception {        if (trip.getHaulierGhtVehicle() != null)            ghTourService.createOrUpdateTour(trip, trip.getHaulierGhtVehicle());        if (trip.getHaulierTrailerGhtVehicle() != null)            ghTourService.createOrUpdateTour(trip, trip.getHaulierTrailerGhtVehicle());        if (trip.getRmoGhtVehicle() != null)            ghTourService.createOrUpdateTour(trip, trip.getRmoGhtVehicle());    }    private static final String snapshootUrl = String.format(            "https://maps.googleapis.com/maps/api/staticmap?size=%s&key=%s&path=enc:",            GOOGLE_API_SNAPSHOT_RESOLUTIONS, GOOGLE_API_KEY);    private String createRouteSnapshot(RouteMapInnerEntity routMap) throws Exception {        String imgBase64 = null;        StringBuilder stringBuilder = new StringBuilder(snapshootUrl);        stringBuilder.append(routMap.getPolylineHash());//        List<LatLng> paths = PolyUtil.decode(routMap.getPolylineHash());        /*for (LatLng path : paths) {            stringBuilder.append(String.format("%s,%s|", path.lat, path.lng));        }*///        stringBuilder.deleteCharAt(stringBuilder.length() - 1);        HttpURLConnection conn = null;        try {            URL url = new URL(stringBuilder.toString());            conn = (HttpURLConnection) url.openConnection();            int responseCode = conn.getResponseCode();            BufferedInputStream response;            if (responseCode == HTTP_OK) {                response = new BufferedInputStream(                        conn.getInputStream());                ByteArrayOutputStream out = new ByteArrayOutputStream();                byte[] buf = new byte[1024];                int n = 0;                while (-1 != (n = response.read(buf))) {                    out.write(buf, 0, n);                }                response.close();                out.close();                buf = out.toByteArray();                imgBase64 = Base64Utils.encodeToString(buf);            } else {                throw new Exception("Some error from google API: " + conn.getResponseMessage());            }            return imgBase64;        } catch (Throwable t) {            LogUtil.error(TAG, t, "Error on creating snapshot.");            return imgBase64;        } finally {            if (conn != null) conn.disconnect();        }    }    private List<Trip> getApprovedTripList() throws Exception {        List<Trip> res;        Session session = null;        Transaction transaction = null;        try {            session = sessionFactory.getCurrentSession();            transaction = session.beginTransaction();            res = tripDao.find(                    "SELECT e FROM " + Trip.class.getSimpleName() + " e " +                            "WHERE e.liveState = :liveState",                    new AbstractDao.StrParam("liveState", APPROVED.name()));            transaction.commit();            transaction = null;            return res;        } finally {            if (transaction != null && !transaction.wasCommitted()) {                LogUtil.warn(TAG,"TRANSACTION ROLLBACK getApprovedTripList.");                transaction.rollback();            }            if (session != null && session.isOpen()) session.close();        }    }    private String findUserDepartment(User currentUser, TripLifeStateType liveState) throws Exception {        Session session = null;        Transaction transaction = null;        StringBuilder conditions = new StringBuilder(                "SELECT e FROM " + Trip.class.getSimpleName() + " e " +                        "WHERE e.liveState = '" + liveState + "'");        boolean isAdmin = WorkflowUtil.isCurrentUserInRole("ROLE_ADMIN");        if ((currentUser.getEmployments() != null && currentUser.getEmployments().size() > 0) || isAdmin) {            Group group = (Group) currentUser.getGroups().iterator().next();            if (group.getId().toUpperCase().contains(UserRoleType.HAULIER.toString())) {                //hauler has only his department                conditions.append("AND haulierDepartmentId = '")                        .append(((Employment) currentUser.getEmployments().iterator().next()).getDepartmentId()).append("' ");            } else if (group.getId().toUpperCase().contains(UserRoleType.RMO.toString())) {                //rmo has only his department                conditions.append("AND rmoDepartmentId = '").append(((Employment) currentUser.getEmployments().iterator().next()).getDepartmentId()).append("\' ");            } else if (group.getId().toUpperCase().contains(UserRoleType.CUSTOMER.toString()) ||                    group.getId().toUpperCase().contains(UserRoleType.SUBSIDIARY.toString())) {                //customer can see subsidiaries departments                List<Department> departments = null;                try {                    session = sessionFactory.getCurrentSession();                    transaction = session.beginTransaction();                    departments = departmentDao.find();                    transaction.commit();                    transaction = null;                } catch (Exception e) {                    LogUtil.error(TripServiceImpl.class.getName(), e, "Error on getting departments for customer");                } finally {                    if (transaction != null && !transaction.wasCommitted()) {                        LogUtil.warn(TAG,"TRANSACTION ROLLBACK findUserDepartment(User currentUser, TripLifeStateType liveState). currentUserId: " + currentUser.getId());                        transaction.rollback();                    }                    if (session != null && session.isOpen()) session.close();                }                String customerDepartmentId = ((Employment) currentUser.getEmployments().iterator().next()).getDepartmentId();//need test this                if (departments != null) {                    List<String> customerDepartmentIds = getChildDepartments(customerDepartmentId, departments);                    conditions.append("AND requesterDepartmentId IN( ");                    for (String id : customerDepartmentIds) {                        conditions.append("\'").append(id).append("\'").append(",");                    }                    conditions.append(")");                }            }        }        return conditions.toString().replace(",)", ")");    }    private List<String> getChildDepartments(String parentDepartmentId, List<Department> departments) throws Exception {        List<String> ids = new ArrayList<>();        for (Department department : departments) {            if (isNotBlank(department.getParentId()) && department.getParentId().equals(parentDepartmentId)) {                ids.addAll(getChildDepartments(department.getId(), departments));            }        }        ids.add(parentDepartmentId);        return ids;    }    private TripOutResp updateVehicleLastLocation(Transaction transaction, TripOutResp tripOutResp) throws Exception {        if (tripOutResp == null) return null;        if (transaction == null || !transaction.isActive())            throw new IllegalArgumentException();        for (VehicleOutResp vehicle : tripOutResp.getVehicleList()) {            Log log = logDao.findSingle(                    "SELECT e FROM " + Log.class.getSimpleName() + " e " +                            "WHERE e.tripId = :tripId " +                            "AND e.vehicleId = :vehicleId " +                            "AND e.lat IS NOT NULL " +                            "AND e.lng IS NOT NULL ",                    new AbstractDao.Order[]{new AbstractDao.Order("e.date", DESC)},                    new AbstractDao.StrParam("tripId", tripOutResp.getId()),                    new AbstractDao.StrParam("vehicleId", vehicle.getVehicleId()));            if (log != null) vehicle.setCurrentPosition(Location.update(new Location(), log));        }        return tripOutResp;    }}